import java.io.IOException;
import java.util.Scanner;

public class Main {

   public static void main(String[] args) throws IOException {

      Scanner scan = new Scanner(System.in);

      System.out.printf("WELCOME!\n\n");

      // Task 2
      task2();

      // Task 3
      //task3();

      // Task 4 - Hill Climbing
      int ITERATIONS_4 = 500;
      TaskResult result = task4(ITERATIONS_4);
      Graph hillGraph = new Graph(result.getMaxGraph());
      GUI hillGui = new GUI();
      hillGui.run(hillGraph, "HillGraph");
      int hillK = Algorithms.BFS(hillGraph).getK();
      int[] distancePerCell = hillGraph.getDistances();
      GUI solutionHillGUI = new GUI();
      solutionHillGUI.createNumberOfMovesGUI(hillGraph.getN(),
              distancePerCell, "HillGraph = " + hillK);

      // Task 5 - SPF
      System.out.println("TASK 5:");
      task5(hillGraph);

      // Task 6 - A*
      System.out.println("TASK 6:");
      task6(hillGraph);

      // Task 7 - Genetic Algorithm
      int ITERATIONS_7 = 200;
      result = task7(ITERATIONS_7);
      Graph geneticGraph = new Graph(result.getMaxGraph());
      GUI geneticGui = new GUI();
      hillGui.run(geneticGraph, "GeneticGraph");
      int geneticK = Algorithms.BFS(hillGraph).getK();
      distancePerCell = hillGraph.getDistances();
      GUI solutionGeneticGUI = new GUI();
      solutionHillGUI.createNumberOfMovesGUI(geneticGraph.getN(),
              distancePerCell, "GeneticGraph = " + geneticK);
      System.out.printf("Genetic Algorithm Complete!\n\n");

      System.out.println("SPF on Genetic graph:");
      task5(geneticGraph);
      System.out.println();

      System.out.println("A* on Genetic graph:");
      task6(geneticGraph);

      // Task 9
      System.out.println("TASK 9:");
      task9();
   }

   private static void task2() {

      System.out.printf("TASK 2:\nPlease enter any size n " +
              "[1..100] to generate a new graph and a visualization of " +
              "its solution.\n(NOTE: values under 40 are preferable in " +
              "order to see visualization clearly).\n");
      Scanner scan = new Scanner(System.in);
      int n = scan.nextInt();
      while (n <= 1 || n > 100){
         System.out.println("Please provide a value larger than 1, but" +
                 " no larger than 100");
         n = scan.nextInt();
      }
      Graph graph = new Graph(n);
      graph.populateGraph(); // binds numbers of jumps to graph
      graph.populateNeighbors();
      GUI gui = new GUI();

      System.out.printf("Creating %s-by-%s sized puzzle...\n", n, n);
      gui.run(graph, "Task 2");
      System.out.printf("Finished creating %s-by-%s sized puzzle.\n", n, n);


      GUI numberOfMovesGUI = new GUI();
      Solution solution = Algorithms.BFS(graph);
      int[] distancePerCell = graph.getDistances();
      System.out.println(solution);
      int k = solution.getK();
      numberOfMovesGUI.createNumberOfMovesGUI(n, distancePerCell,
              "Task 2 = " + k);
      return;
   }


   /**
    * Task 3 Driver Method.
    */
   private static void task3() {


      System.out.printf("\nTASK 3:\nSee the 8 puzzles generated by this " +
              "task.\nEach size (5, 7, 9 & 11) has two puzzles each; one " +
              "with a positive k value and one with a negative k value.\n" +
              "Each puzzle is provided with a corresponding visualization " +
              "of it's solution\n");
      int[] puzzleSizes = new int[]{5, 7, 9, 11};
      for (int puzzleSize : puzzleSizes){
         createT3Puzzles(puzzleSize, true);
         createT3Puzzles(puzzleSize, false);
      }
      return;
   }

   /**
    * Task 4 Driver Method.
    */
   private static TaskResult task4(int iterations) {

      System.out.println("\n\nTASK 4:");
      System.out.printf("Generating a graph using HillClimbing algorithm " +
              "with %s iterations...\n", iterations);
      int[] puzzleSizes = new int[]{5, 7, 9, 11};
      int ITERATIONS = iterations;
      Solution solutions[][] = new Solution[puzzleSizes.length][ITERATIONS];
      double times_ms[][] = new double[puzzleSizes.length][ITERATIONS];
      int maxK = 0;
      Graph maxGraph = null;
      for (int i = 0; i < puzzleSizes.length; i++) { // for each puzzle size
         maxK = 0;
         maxGraph = null;
         for (int j = 0; j < ITERATIONS; j++) {
            Graph graph = new Graph(puzzleSizes[i]);
            graph.populateGraph();
            graph.populateNeighbors();
            graph.setDistances();
            Solution solution = Algorithms.BFS(graph);
            Result hillResult = Algorithms.HillClimbing(graph, solution, j);
            solution = hillResult.getSolution();
            double time_ms = hillResult.getComputationTime_ms();
            if (solution.getK() > maxK){
               maxK = solution.getK();
               maxGraph = new Graph(graph);
            }
            solutions[i][j] = solution;
            times_ms[i][j] = time_ms;
         }
      }
      System.out.printf("Hill Climbing Algorithm Complete!\n\n");
      TaskResult result = new TaskResult(solutions, times_ms, maxK, maxGraph);
      return result;
   }


   private static void task5(Graph difficultGraph) {

      Graph graph = new Graph(difficultGraph);
      Solution solution = Algorithms.SPF(graph);
      System.out.println("The result of SPF:");
      System.out.println(solution);
   }

   private static void task6(Graph difficultGraph) {
      Graph graph = new Graph(difficultGraph);
      Solution solution = Algorithms.AStarSearch(graph);
      System.out.println("The result of A*:");
      System.out.println(solution);

   }

   private static TaskResult task7(int iterations) {

      System.out.println("TASK 7:");
      System.out.printf("Generating a graph using Genetic algorithm " +
              "with %s iterations...\n", iterations);
      int[] puzzleSizes = new int[]{5, 7, 9, 11};
      int populationSize = 4;
      int ITERATIONS = iterations;
      Solution solutions[][] = new Solution[puzzleSizes.length][ITERATIONS];
      double times_ms[][] = new double[puzzleSizes.length][ITERATIONS];
      int maxK = 0;
      Graph maxGraph = null;
      for (int i = 0; i < puzzleSizes.length; i++) {
         maxK = 0;
         maxGraph = null;
         for (int j = 0; j < iterations; j++) {
            Graph graph = new Graph(puzzleSizes[i]);
            graph.populateGraph();
            graph.populateNeighbors();
            graph.setDistances();
            Solution solution;
            Result geneticResult = Algorithms.Genetic(puzzleSizes[i], populationSize, j+1);
            solution = geneticResult.getSolution();
            graph = geneticResult.getGraph();
            double time_ms = geneticResult.getComputationTime_ms();
            if (solution.getK() > maxK){
               maxK = solution.getK();
               maxGraph = new Graph(graph);
            }
            solutions[i][j] = solution;
            times_ms[i][j] = time_ms;
         }
      }
      TaskResult result = new TaskResult(solutions, times_ms, maxK, maxGraph);
      return result;
   }

   private static void task9() {

      int n = 1000;
      Graph graph = new Graph(n);
      graph.populateGraph(); // binds numbers of jumps to graph
      graph.populateNeighbors();

      Solution solution = Algorithms.BFS(graph);
      int iterations = 100;
      Solution solution2;
      System.out.printf("Performing Hill Climbing algorithm to create a " +
                 "difficult %s-by-%s puzzle...\n\n", n, n);
      Result hillResult = Algorithms.HillClimbing(graph, solution, iterations);
      Graph hillGraph = hillResult.getGraph();

      //GUI gui = new GUI();
      //gui.run(hillGraph, "Super Crazy Difficult Puzzle worthy of extra credit");

      System.out.println("BFS search on result of HillClimbing");
      solution2 = Algorithms.BFS(hillGraph);
      System.out.println(solution2);

      System.out.println("SPF search on result of HillClimbing");
      Solution solution4 = Algorithms.SPF(hillGraph);
      System.out.println(solution4);

      System.out.println("A* search on result of HillClimbing");
      Solution solution6 = Algorithms.AStarSearch(hillGraph);
      System.out.println(solution6);

      return;
   }

   /**
    * Creates puzzles for Task 3
    * Based on puzzle size creates a puzzle and a visual representation of
    * its solution.\
    * Based on boolean paramater, ensures whether or not the puzzle returned
    * is solvable.
    * @param puzzleSize
    * @param hasSolution
    */
   private static void createT3Puzzles(int puzzleSize, boolean hasSolution) {

      Solution solution;
      Graph graph;

      do {
         graph = new Graph(puzzleSize);
         graph.populateGraph(); // binds numbers of jumps to graph
         graph.populateNeighbors();
         solution = Algorithms.BFS(graph);
      } while ( hasSolution ? solution.getK() < 0 : solution.getK() > 0);

      GUI gui = new GUI();
      String sizeAsStr = Integer.toString(puzzleSize);
      String kStr = Integer.toString(solution.getK());
      String name = hasSolution ?
              "Task 3a: " + sizeAsStr + "x" + sizeAsStr :
              "Task 3b: " + sizeAsStr + "x" + sizeAsStr;
      gui.run(graph, name);

      int[] distancePerCell = graph.getDistances();
      GUI numberOfMovesGUI = new GUI();
      numberOfMovesGUI.createNumberOfMovesGUI(puzzleSize, distancePerCell,
              name + " = " + kStr);
   }

}
